<html lang="en"><head>
    <meta charset="UTF-8">
    <title></title>
<style id="system" type="text/css">*{margin:0;padding:0;}body {	font:13.34px helvetica,arial,freesans,clean,sans-serif;	color:black;	line-height:1.4em;	background-color: #F8F8F8;	padding: 0.7em;}p {	margin:1em 0;	line-height:1.5em;}table {	font-size:inherit;	font:100%;	margin:1em;}table th{border-bottom:1px solid #bbb;padding:.2em 1em;}table td{border-bottom:1px solid #ddd;padding:.2em 1em;}input[type=text],input[type=password],input[type=image],textarea{font:99% helvetica,arial,freesans,sans-serif;}select,option{padding:0 .25em;}optgroup{margin-top:.5em;}pre,code{font:12px Monaco,"Courier New","DejaVu Sans Mono","Bitstream Vera Sans Mono",monospace;}pre {	margin:1em 0;	font-size:12px;	background-color:#eee;	border:1px solid #ddd;	padding:5px;	line-height:1.5em;	color:#444;	overflow:auto;	-webkit-box-shadow:rgba(0,0,0,0.07) 0 1px 2px inset;	-webkit-border-radius:3px;	-moz-border-radius:3px;border-radius:3px;white-space: pre-wrap;word-wrap:break-word;}pre code {	padding:0;	font-size:12px;	background-color:#eee;	border:none;}code {	font-size:12px;	background-color:#f8f8ff;	color:#444;	padding:0 .2em;	border:1px solid #dedede;}img{border:0;max-width:100%;}abbr{border-bottom:none;}a{color:#4183c4;text-decoration:none;}a:hover{text-decoration:underline;}a code,a:link code,a:visited code{color:#4183c4;}h2,h3{margin:1em 0;}h1,h2,h3,h4,h5,h6{border:0;}h1{font-size:170%;border-top:4px solid #aaa;padding-top:.5em;margin-top:1.5em;}h1:first-child{margin-top:0;padding-top:.25em;border-top:none;}h2{font-size:150%;margin-top:1.5em;border-top:4px solid #e0e0e0;padding-top:.5em;}h3{margin-top:1em;}hr{border:1px solid #ddd;}ul{margin:1em 0 1em 2em;}ol{margin:1em 0 1em 2em;}ul li,ol li{margin-top:.5em;margin-bottom:.5em;}ul ul,ul ol,ol ol,ol ul{margin-top:0;margin-bottom:0;}blockquote{margin:1em 0;border-left:5px solid #ddd;padding-left:.6em;color:#555;}dt{font-weight:bold;margin-left:1em;}dd{margin-left:2em;margin-bottom:1em;}@media screen and (min-width: 768px) {    body {        width: 748px;        margin:10px auto;    }}</style><style id="custom" type="text/css"></style></head>
<body><p>title: "如何在 Swift 中使用 CommonCrypto 类进行加密"
date: 2015-8-29
tags: [Swift]
categories: [digitalleaves]
permalink: cryptography-in-swift-with-commoncrypto

</p>
<hr>
<p>原文连接：<a href="http://digitalleaves.com/blog/2015/08/commoncrypto-in-swift/?utm_campaign=Swift%2BSandbox&amp;utm_medium=web&amp;utm_source=Swift_Sandbox_3">Cryptography in Swift with CommonCrypto</a>


</p>
<p><img src="http://img-storage.qiniudn.com/15-8-23/34909577.jpg" alt="">

</p>
<p>现在，许多开发者已经不需要在 App 中进行加密处理。即使你在远程服务器上使用了 REST API，通常情况下使用 HTTPS 就可以解决大多数的安全通信问题，剩下的问题可以使用苹果提供的“保护模式”和硬件/软件加密组合方式来解决。然而在很多情况下，你还是需要对通信或文件进行加密。也许你正在把一个现有的涉及到文件/信息加密的方案移植到 iOS 上，也许你在制作一个保密性要求极高的App，或者你只是想提高数据的安全级别（这是一件好事）。

</p>
<p>无论是哪种情况，（在iOS和OS X系统中）Cocoa 都选择 CommonCrypto 来完成任务。然而 CommonCrypto 的 API 使用的仍然是老旧的C风格（C-Style）。这种 API 已经过时了，在 Swift 中用它们非常别扭。此外，在 Swift 中用强类型属性处理 CCCrypt 中不同类型的数据（对称式加密框架的主要加密/解密功能）很不优雅。我们先来看一下 CCCrypt 的定义：

</p>
<pre><code>CCCrypt(op: CCOperation, alg: CCAlgorithm, options: CCOptions, key: UnsafePointer&lt;Void&gt;, keyLength: Int, iv: UnsafePointer&lt;Void&gt;, dataIn: UnsafePointer&lt;Void&gt;, dataInLength: Int, dataOut: UnsafeMutablePointer&lt;Void&gt;, dataOutAvailable: Int, dataOutMoved: UnsafeMutablePointer&lt;Int&gt;)</code></pre>
<p>再来看看 Objective-C（更准确来说是 C 版本的）函数声明：

</p>
<pre><code>CCCryptorStatus CCCrypt(
 CCOperation op,          // operation: kCCEncrypt or kCCDecrypt
 CCAlgorithm alg,         // algorithm: kCCAlgorithmAES128... 
 CCOptions options,       // operation: kCCOptionPKCS7Padding...
 const void *key,         // key
 size_t keyLength,        // key length
 const void *iv,          // initialization vector (optional)
 const void *dataIn,      // input data
 size_t dataInLength,     // input data length
 void *dataOut,           // output data buffer
 size_t dataOutAvailable, // output data length available
 size_t *dataOutMoved)    // real output data length generated</code></pre>
<p>在 Objective-C 中，可以简单地使用预定义常量（比如“kCCAlgorithm3DES”）来定义这些参数，然后传入不同的数组和大小，完全不必担心它们的确切类型（给 size_t 参数传入 int 变量，或者给 void<em> 参数传入 char</em> 变量）。这不是最好的做法，但确实可以完成任务（只需要进行一些类型转换）。

</p>
<p>但是 Swift 剔除了 Objective-C 中属于 C 的部分，因此我们需要做一些准备工作才能在 Swift 和 Cocoa 中使用 CommonCrypto。

</p>
<h2>操作（Operation）、算法（Algorithm）和设置（Options）</h2>
<p>在 App 中对称编码是最简单的一种发送和接收加密数据的方法。这种方法只有一个密钥，它用于加密和解密操作（非对称加密则不同，它通常使用一对公－私密钥）。对称密码有许多不同的算法，所有的算法都可以有不同的设置。三个主要概念是：操作（加密/解密）、算法（DES，AES，RC4……）和设置，对应 CommonCrypto 的 CCOperation、CCAgorithm 和 CCOptions。

</p>
<p>CCOperation、CCAgorithm 和 CCOptions 本质上就是 uint32_t（一个占32位存储的 unsigned int），所以我们可以通过 CommonCrypto 常量来构造它们：

</p>
<pre><code class="lang-swift">let operation = CCOperation(kCCEncrypt)
let algorithm = CCAlgorithm(kCCAlgorithmAES)
let options = CCOptions(kCCOptionPKCS7Padding | kCCOptionECBMode)</code></pre>
<h2>Unsafe 指针</h2>
<p>Swift 抽象出 Unsafe 指针来对应 C 语言的指针(C-Pointers)。Swift 试图把所有的指针和 C 风格的内存管理器都抽象出来。通常来说你不需要使用它们，除非你需要使用旧式(old-style)API(比如 CommonCrypto)。如果你真的如此不幸，那就需要学习如何处理它们：

</p>
<p>在 Swift 中有两种类型的指针：UnsafePointers 和 UnsafeMutablePointers 类型。第一个用于常量寄存器，内存空间上的指针是恒定不变的；第二个用于可变的内存空间。对应到 C 语言，UnsafePointer 类型是"const type <em>"缓冲类型，UnsafeMutablePointer 是"type </em>"缓冲类型（这里的"缓冲"一词只是过去习惯的叫法）。指针的具体类型写在声明之后的&lt;&gt;中，所以如果你想去声明一个"void <em>"类型的指针，需要写成：UnsafeMutablePointer<void>。如果要声明"const unsigned char </void></em>"缓冲类型的指针，你需要使用：UnsafePointer<uint8>。虽然苹果确实提供了纯 C 类型到 Swift 类型的转换，但是一定要注意，CChar、CInt、CUnsignedLongLong…这样的类型不能直接用在 UnsafePointers 中，需要使用原生的 Swift 类型。这就出现一个问题，到底什么时候能用这些类型呢？我们需要深入一下 Swift 的类型定义：

</uint8></p>
<pre><code class="lang-swift">typealias CShort = Int16
typealias CSignedChar = Int8
typealias CUnsignedChar = UInt8
typealias CUnsignedInt = UInt32
typealias CUnsignedLong = UInt
typealias CUnsignedLongLong = UInt64
typealias CUnsignedShort = UInt16</code></pre>
<p>值得庆幸的是我们不需要实现 UnsafePointers 和 UnsafeMutablePointers 类型的内存管理（只要你使用的是类似 NSData 这样的 Cocoa 对象）。Swift 会自动管理（和桥接）它们。如果你需要加密/解密数据并把密钥存到 NSData 中，那就可以调用<code>calling data.bytes</code>或者<code>data.mutableBytes</code>来获取对应的 UnsafePointer 和 UnsafeMutablePointer 指针。

</p>
<p>另一种得到 UnsafePointer 变量的方式是<code>&amp;</code>。处理输出变量时(需要内存的地址)就是通过&amp;符号得到 Int 类型的 Unsafe(Mutable)Pointer<int>。我们可以在 CCCrypt 中使用这种方法把"Int"变量地址传给最后一个参数 ："dataOutMoved" 。注意：let 定义的变量对应 UnsafePointer<type> 类型，var 变量对应 UnsafeMutablePointer<type> 类型。

</type></type></int></p>
<p>现在，我们已经拥有了调用 CCCrypt 所需的所有元素。

</p>
<h2>桥接</h2>
<p>CommonCrypto 还没有兼容 Swift，所以为了使用它，我们需要通过头文件导入 Objective-C 形式的 CommonCrypto。


</p>
<pre><code class="lang-swift">#import &lt;CommonCrypto/CommonCrypto.h&gt;</code></pre>
<h2>SymmetricCryptor</h2>
<p>最近我需要做对称加密的项目，为了更容易的加密和解密数据，我建了一个<code>SymmetricCryptor</code>类（不要在意这个可怕的名字）。它可以把数据转换成恰当的 CommonCrypto 类型中。你可以使用它来方便的加密或解密数据。

</p>
<pre><code class="lang-swift">let sc = SymmetricCryptor(algorithm: .AES128, options: CCOptions(kCCOptionPKCS7Padding))
cypher.setRandomIV()
do { let cypherText = try sc.crypt(string: clearText, key: key) } catch { print("Error while encrypting: \(error)") }</code></pre>
<p>CommonCrypto 提供了多种算法和设置，不过我只想解决最常见的加密问题，因此简化了配置。比如说，使用 RC4 的时候，你可以使用 40 或者 128 位的密钥（对应的常量是 RC4_40 和 RC4_128）。同理，AES 也有一些常用的常量（128b、256b……）。因此我定义了一个名为<code>SymmetricCryptorAlgorithm</code>的枚举变量，里面定了许多常见的配置（比如 AES 256），不仅包含算法，还包含很多其他信息，比如密钥长度和块大小。

</p>
<p>在 SymmetricCryptor 的 GitHub 页面中，你可以看到一个对称加密/解密示例，它展示了如何简单地实现对称加密/解密。

</p>
<p><img src="http://img-storage.qiniudn.com/15-8-23/36052539.jpg" alt="">

</p>
<p>我会继续介绍非对称加密技术和公私密钥对，如果感兴趣请继续关注我。
Edit By <a href="http://mahua.jser.me">MaHua</a></p>
</body></html>